url: uniform resource locator

https (hyper text transfer protocol secure): the 'language' client and server speak. secure means that the communication is encrypted (the browser authomatically adds 'https://...' when you enter the url)

IP (Internet Protocol) address: a unique identifier of network devices for establishing connections and talking with each other. domains are more readible by humans, but are not used to establish connections and sending requests, although if you knew the IP address of a website, you can use it insted of using the domain and it would work (all devices that are part of the internet need an IP address, but for example, your computer, if it's not hosting a website, doesn't have a humanly readible domain; every device has an IP address, but not every device has a domain, that's why we use IP addresses to establish conections). that's why we have special servers, operated by global organizations: DNS servers (domain name system). these servers contain translation tables between domains and ip addresses that belong to these domains (the ip addresses of the remote computers that host the websites that belong to certain domains).

when you enter a url in your browser, your browser first talks to a DNS server to translate the domain into an ip address, and then once the ip address was returned, then your browser sends the request to that remote machine (the server identified with the ip address that is serving that website)

even though your computer has an ip address (if connected to the internet), you don't have to worry that other user will access it, since typically it doesn't allow incoming external traffic from other users. to host a website, appropriate 'entry points' (Ports) must be opened in the network and your computer must be configured as a web server.

A lot of websites can be visited via different domains. For example, the Amazon website can be visited via amazon.com but also via www.amazon.com. Both addresses can be entered in the browser and you will reach the same website.

So what's the difference?

Especially in the earlier days of the internet, it was also often called the "world wide web" (or: "www"). You still hear that term quite a bit and it's this term, that explains why some websites support such a "www" prefix in the domain.

Technically, www.amazon.com is called a "subdomain" of the "root domain" amazon.com. As the operator of a website and the owner of a domain, you can register any subdomains you want to. You could also register mysite.amazon.com, if you were the owner of the amazon.com domain. And you can then configure your web server such, that your website is served, if users enter mysite.amazon.com.

That's what many (but not all) websites do with the "www" subdomain: They register it and configure it such, that it also points at the main website.

It's not required and not all websites have it. Most users also don't type "www.somewebsite.com" manually anymore - instead just the root domain is entered in many cases.

the different html tags give different instructions to the browser (what content has to be a header, a paragraph, etc.)

html is a markup language: a language that is there to add up some extra annotation/meaning/description to the content that you have in your page.

html instructs the browser about content, its structure and its meaning.

remember, browsers are very forgiving, that's why content will be displayed as plain text, even if you don't use html tags.

html attributes allow to to add extra configuration to the html element. different html elements support different attributes, for example, basically all html elements support the 'style' attribute to add css styling to an element (remember, an html atribute has a name, and a value). for example: style="font-family: sans-serif"

css has properties and values for these properties.
a css rule is a property with its value.

remember, we don't use an html element (eg. h1) because we want certain styling (bold letters, etc.) (with css, we could make a paragraph with bold letters, or we could make an h1 look like a paragraph, etc.). we use it html elements because we want to convey meaning to search engines, screen readers, etc.

you can add the 'style' attribute to basically any html element. we say 'basically' because later we will talk about a few elements that can't be styled because they are not visible.

under the 'color' property, we have some named colors (for example, 'red', 'blue' etc.) but we actually have millions of colors at our disposal. we have hex codes (three pairs of numbers that together refer to combinations of red, green and blue) for colors becase we have more than 16 million colors, and we would have very long numbers if we used the decimal system. 
you can google 'color picker' and manually select the color that you want (vscode also gives you this possibility, and you can also see the colors in the 3 different denominations (hex code, rgb, or hsl)) (see 'colors.pdf').

code formatter extension: prettier (set it under 'default formatter')

if you want to find what styles are applied into an element, you could check the source code, but what about the default styles applied by the browser? you can check that in devtools. 'user agent' styles will tell you what default styles are applied by the browser, and 'element.style' will tell you what styles you applied inline (see screenshot). 

emmet is a built-in plug-in of vscode, that helps with autocompletion of elements.

revise css pseudo selectors.

cascading style sheets, means that multiple different rules can affect an element at the same time. for example, see screenshot, some user agent rules (default styling by the browser) still apply to the element, but some of them some are overriden by our rules

the 'link' element is an example of a 'void element' because it has no content between opening and closing tags, hence there is no closing tag. 'void elements' are configured with attributes only. when we are configuring the 'link' attribute, apart from the 'href' attribute, we also use the 'rel' attribute to specify what kind of relationship we are creating with this link.

for void elements, you can use a <self closing tag />, or just <nothing>

the way a page is rendered on the screen is: after loading the html file, the browser requests the css file that is linked into it (it will also request js files, images, etc; all these are different request-reponse cycles). you can see all these requests in the 'network' tab of devtools, and you can even simulate that you have a slower connection to check how fast your side would load (see screenshots).

when you use google fonts, you make sure that the fonts will be requested by the browsers of the visitor of your website. you also use the 'link' element and add the url in the 'href' attribute (with the 'href' attribute, we can link not only css files, but also point at google's servers, so the fonts will be downloaded by the browser when the user visits the website, and make sure that the browser will be able to use these fonts). when you add several fonts from google fonts in the css file, they are evaluated form left to right, and if some font fails (maybe because google's servers are down or similar), then you have the other backup options of your choice (typically, some font family that your browser can use, eg. sans-serif...).

//

How To Output Special Characters In HTML
When writing HTML code, characters like "<" and ">" obviously have a special meaning: They mark the beginning and ending of HTML tags.

But what if you would want to output the "<" and ">" characters or a complete HTML tag as text on your website? Like on this site here (yes, the site on which you currently are). You can read the code snippets above just fine - because they are output as plain text (they are NOT interpreted as HTML by the browser that loaded this page).

There are two main ways of achieving this:

You can use the special <pre>...</pre> tags (for "preformatted text") - these tags wrap any text (that may include HTML code) and "tell the browser" to output it as plain text (i.e. NOT interpret it as HTML code). When using <pre>, whitespace is also preserved and NOT ignored (as it normally would be)

Alternatively, if you simply want to output the "<" character (e.g. in some math formula that should be shown on your page), you can use some special "shortcuts" (so-called "HTML entities") in your HTML code:

E.g. if you write &gt; in your HTML code, the browser will output the ">" (greater than) symbol

&lt; => "<" (lower than)

//

in css, 'text-align' centers not the html element, but its content (eg. it doesn't center the paragrph, but the text of the paragraph). therefore, if you want to center an image, if you apply this property to the image it will do nothing, you should apply this property to the whole body. this is something that often happens in css: you have to target the parent element.

it's a good practice to structure your css code, so it comes pretty much in the same order as the html code

you can add several 'link' elements (pointing to the relative paths of several css files) in your html file, so the consecutive linked css files complement or override the previous ones. 

//

What's This Address: 127.0.0.1?
As mentioned above, this development web server hosts (= provides / serves) the website from our local machine to our local machine.

In section 1, you learned that users enter addresses (URLs) into the browser address bar to reach a website and send such a request. You also learned that the human-readable "domains" (like academind.com) are translated to IP addresses which act as unique identifiers of machines connected to the internet.

127.0.0.1 is such an IP - though it's a special one!

127.0.0.1 is a special IP, that's reserved to your local machine. And it's the local machine for everyone!

If I type 127.0.0.1 into the browser, I connect to my local machine (if it's running a local web server). You reach your machine.

It's an IP address that's NOT assigned to other machines in the world wide web - instead it's reserved as a "placeholder" that always points at your local machine. It exists for use-cases as we have it here: For development on our local machine, where we want to test our website with help of a local development server. I.e. we can test it locally without exposing it to the entire world yet.

There also is an alias (basically like a "special domain name") that you can use locally, instead of 127.0.0.1: localhost. You can also enter localhost into your browser and it will be the same as if you entered 127.0.0.1. So localhost:5500 is a replacement for 127.0.0.1.

What's This Thing: :5500?
The :5500 part is a so-called "port".

Ports are another concept from the networking world. The idea is, that a machine can expose different processes (e.g. different web servers serving different websites) via different ports.

So a single machine could host / provide three different websites on three different ports. The IP address of the local machine would always be the same (127.0.0.1) but every website would have its own port (e.g. 5500, 3000, 8080).

If you move a website to some machine that IS exposed to the world wide web (i.e. you publish it, you don't run it via a development web server on your local machine anymore), then the website is reached via the IP address of that remote machine. Or, typically, via a domain that's pointing at that IP address.

In addition, this port concept also still exists: When exposed to the world wide web, websites are typically served on ports 80 (HTTP) or 443 (HTTPS). You don't need to worry about this right now though. When publishing a website (covered later in the course), the different hosting providers typically take care about exposing the right ports automatically.

When working on your local machine, you don't use these "common ports" (80, 443) since you're not exposing the website to the world wide web anyways. Instead, you can use ANY ports that are typically not used by any other processes - 5500, 3000 or 8080 are common choices because they aren't typically used by other processes.

That's why the "Live Server" extension does use port 5500 for serving your website locally.

And you target a specific port by adding :<port-number> after the domain or IP address. That's why 127.0.0.1:5500 resolves to that locally served website. Alternatively, since 127.0.0.1 is aliased with localhost, you could also enter localhost:5500.

You can try this with other websites, too!

Try visiting academind.com:443 or academind.com:80 => You will see the regular Academind website. Of course you don't need to add the extra port information in the URL though - since 80 and 443 are the defaults, the browser will use these ports automatically, if you enter a website address.