protected content is not only the page that you see when you login, but it could also be some data that you are storing in a database, or some api endpoints that your app might be sending requests in certain pages that should be restricted from non-authenticated users (in our example, the request that will be sent to the server when we click on the 'change password' button, so the password is changed in the database: therefore, we want to restrict the page where the user can change the password, but also the api endpoint to which we send the request to change the password).

when you login, you send your credentials, and this data is sent to some server where we can look into some database and veriry your password and email, and if that's valid, the server grants this permission, when we have this permission we can unlock certain pages of the website, and/or send subsequent request to other protected resources to api endpoints.

since we could send a fake 'yes' to the server, authentication is a bit more elaborated: not only we need to send and check the credentials, but the response send back by the server to the client must be more than just a 'yes' or 'no'. and here we have two approaches that we can use: server-side sessions or authentication tokens.
server-side sessions: (traditional approach) once a server grants you access, that server stores a unique identifier for your client (for this specific user who was just granted access): the server stores a unique identifier for this specific client (every user that registers gets its own identifier stored on the server). but this identifier is not only stored in the server, it's also sent back to the client (remember, a 'yes' or 'no' response is not enough, it also includes this identifier), and this identifier is attached to future requests to the server, and since the server knows this identifier, it can't be faked. this approach works well if server and client are tightly coupled, but if you have de-coupled ends (if you have your spa served by server A, and your backend application, your rest api, is served by server B, then both ends should work independently, for example, an api that can be used by many websites, like the google maps api, then this api can't be tightly coupled with a single frontend, instead it needs to stay flexible, and that's why you don't want to store some identifier on the server, the server should be stateless (it should not store this data about the connected clients): when you are building spa, you will very often have to deal with that situation, this is what we are going to focus on: in this situation you can use authentication tokens: the basic idea is the same: you send your credentials to the server, and the server checks whether or not the credentials match with what's stored on the database. if that's valid, then the server creates a permission token (a very long string with some data encoded into that string; the server will use some algorithm to encode some data, like the email of the user, into one string, which cannot be decoded back into those pieces of data. this string (the token) will be generated with an algorithm and with a key which will be used for hashing that data into a string, and this key is only known by the server, not by the client). this token is not stored by the server, but sent back to the client, but only the server knows how to create that token (because of that key which is involved). then, the client can use that token to attach it to future requests to protected resources on the server. even though the server has not stored this identifier (as it happens with the server-side sessions approach), the server is able to identify that that the token was created by it, because only the server knows this private key that was involved in the token creation process, and therefore the incoming token (which is attached to the request for some protected resource) can be validated by the server (the server is able to check if that token was created by it, by the server). and if the token was faked, or created with a different key, then the server will detect this and will deny access. this approach allows for decoupling between frontend and backend, and this is the approach that we are going to use in our app.

(remember, the main idea of the token approach is that the server does not store any info about the logged in client)

When working with "Authentication Tokens", these tokens are typically created in the "JSON Web Token" Format (JWT).
As explained in the previous lecture, those "tokens" are really just long strings which are constructed by an algorithm that encodes data into a string (with help of a private key, only known by the server).
You can learn more about JSON Web Tokens (JWTs) here: https://jwt.io/

with firebase, you can use the Firebase Auth Rest Api (check the docs)

using firebase: watch video 304 (Adding user sign up), 306 (Adding user login), 308 (Using the token for requests to protected resources)