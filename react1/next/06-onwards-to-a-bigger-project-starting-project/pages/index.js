// our-domain.com
import { useState, useEffect } from 'react';

// import Layout from '../components/layout/Layout';
import MeetupList from '../components/meetups/MeetupList';

const DUMMY_MEETUPS = [
	{
		id: 'm1',
		title: 'First meetup',
		image:
			'https://commons.wikimedia.org/wiki/File:Bayerische_Staatskanzlei_Munich_2014_02.jpg',
		address: '23 Harrod St',
		description: 'Meetup in beautiful Bucharest',
	},
	{
		id: 'm2',
		title: 'Second meetup',
		image:
			'https://commons.wikimedia.org/wiki/File:Bayerische_Staatskanzlei_Munich_2014_02.jpg',
		address: '23 Harrod St',
		description: 'Meetup in beautiful Bucharest',
	},
	{
		id: 'm3',
		title: 'Third meetup',
		image:
			'https://commons.wikimedia.org/wiki/File:Bayerische_Staatskanzlei_Munich_2014_02.jpg',
		address: '23 Harrod St',
		description: 'Meetup in beautiful Bucharest',
	},
];

function HomePage() {
	const [loadedMeetups, setLoadedMeetups] = useState([]);

	useEffect(() => {
		// send an http request and fetch data
		// we are going to simulate that we are fetching data from a backend:
		setLoadedMeetups(DUMMY_MEETUPS);
	}, []);
	// therefore, we will have two component render cycles: the first time the component is rendered, loadedMeetups will be empty, after the component is rendered, the effect function will be executed, and when the state changes, the component will be re-rendered with the new state. therefore, if we were getting data from a backend, our users would see a loading spinner briefly. but even in our fake situation (we are not sending a request, but loading the DUMMY_MEETUPS that we already have in this file), because of these two render cycles, we have a problem with SEO: if you inspect the source code, you will see that the ul that contains the meetups list is empty, so the items that we see in our page are missing in the html file that we would get from the server. they are missing because they are only rendered in the second component execution cycle, but the pre-rendered (pre-rendered: rendered in the server) html page generated by next.js authomatically does not wait for this second cycle (it always takes the result of the first render cycle). in a nutshell, next.js does not wait for the data to be fetched from a server. but, as we will see, next.js has more features built into it that solve this problem (we want to pre-render a page with data, but with data that we will have to wait for, but next.js doesn't wait for the data, so there will be missing data in the pre-rendered page).
	// the way it works is: after the page is received by the browser, react will take over: the page will be hydrated (react will turn this page into an spa and take over control); then useEffect will be executed, and data will be updated in the browser, not on the server (not on the pre-rendered page, but after this page was received in the browser). but if we want to pre-render a page that already contains the data, we need to configure the pre-rendering process: next.js gives us two forms of pre-rendering that allow us to control how the page is pre-rendered: static generation, and server-side rendering. (typicaly, we should use static generation).

	return (
		// <Layout>
		<MeetupList meetups={loadedMeetups} />
		// </Layout>
	);
}

export default HomePage;
