// our-domain.com
// import { useState, useEffect } from 'react';

// import Layout from '../components/layout/Layout';
import MeetupList from '../components/meetups/MeetupList';

const DUMMY_MEETUPS = [
	{
		id: 'm1',
		title: 'First meetup',
		image:
			'https://upload.wikimedia.org/wiki/File:Bayerische_Staatskanzlei_Munich_2014_02.jpg',
		address: '23 Harrod St',
		description: 'Meetup in beautiful Bucharest',
	},
	{
		id: 'm2',
		title: 'Second meetup',
		image:
			'https://commons.wikimedia.org/wiki/File:Bayerische_Staatskanzlei_Munich_2014_02.jpg',
		address: '23 Harrod St',
		description: 'Meetup in beautiful Bucharest',
	},
	{
		id: 'm3',
		title: 'Third meetup',
		image:
			'https://commons.wikimedia.org/wiki/File:Bayerische_Staatskanzlei_Munich_2014_02.jpg',
		address: '23 Harrod St',
		description: 'Meetup in beautiful Bucharest',
	},
];

function HomePage(props) {
	// const [loadedMeetups, setLoadedMeetups] = useState([]);

	// useEffect(() => {
	// 	// send an http request and fetch data
	// 	// we are going to simulate that we are fetching data from a backend:
	// 	setLoadedMeetups(DUMMY_MEETUPS);
	// }, []);
	// therefore, we will have two component render cycles: the first time the component is rendered, loadedMeetups will be empty, after the component is rendered, the effect function will be executed, and when the state changes, the component will be re-rendered with the new state. therefore, if we were getting data from a backend, our users would see a loading spinner briefly. but even in our ideal fake situation where we already have the data and therefore don't spend any time fetching it (we are not sending a request, but loading the DUMMY_MEETUPS that we already have in this file), because of these two render cycles, we have a problem with SEO: if you inspect the source code, you will see that the ul that contains the meetups list is empty, so the items that we see in our page are missing in the html file that we would get from the server. they are missing because they are only rendered in the second component execution cycle, but the pre-rendered (pre-rendered: rendered in the server) html page generated by next.js authomatically does not wait for this second cycle (it always takes the result of the first render cycle). in a nutshell, next.js does not wait for the data to be fetched from a server. but, as we will see, next.js has more features built into it that solve this problem (we want to pre-render a page with data, but with data that we will have to wait for, but next.js doesn't wait for the data, so there will be missing data in the pre-rendered page). how can we fetch data for pre-rendering?
	// the way it works is: after the page is received by the browser, react will take over: the page will be hydrated with react code once the page has been loaded (react will turn this page into an spa and take over control); then useEffect will be executed, data might be fetched, and that data will be reflected in the browser, not on the server (not on the pre-rendered page, but after this page was received in the browser). but if we want to pre-render a page that already contains the data, so that the originally returned (by the server) html code already contains the data, we need to configure the pre-rendering process: next.js gives us two forms of pre-rendering that allow us to control how the page is pre-rendered: static generation, and server-side rendering (the code runs at different points in time in these two options). (typicaly, we should use static generation).
	// when you use 'static generation', a page component is pre-rendered when you build your app (for production: npm run build). ie. by default, your page is not pre-rendered on the fly on the server when a request reaches the server, but instead is pre-rendered when you as a developer build your site for production, and that means that after it was deployed, that pre-rendered page does not change (if you want to change the data, you need to build again and deploy again) (in some apps, data doesn't change at least that often, so this solution may be convenient). (remember, with static generation, next.js generates your pages statically in the build process, but if you need to add data fetching to a page component, you can do so by exporting a special function (getStaticProps) from your page component file: IT WORKS ONLY IN COMPONENT FILES INSIDE OF THE 'PAGES' FOLDER)

	return (
		// <Layout>
		// <MeetupList meetups={loadedMeetups} />
		<MeetupList meetups={props.meetups} />
		// </Layout>
	);
}

// export async function getServerSideProps(context) {
// 	const req = context.req;
// 	const res = context.res;
// 	// fetch data from api or file system...
// 	return {
// 		props: {
// 			meetups: DUMMY_MEETUPS,
// 		},
// 	};
// }
// this function will not run during the build process, but instead always on the server after deployment. any code we write here will always run on the server, never on the client, so you can write server side code here (and also perform operations that require credentials that should not be exposed to your users). THIS FUNCTION RUNS FOR EVERY INCOMING REQUEST! (so there's no need to revalidate). you can use the 'context' paramenter, where you will be able to access the request object, and the response object that will be sent back (having access to the 'req' object can be helpful for example, when you are working with authentication and you need to check some session cookie or anyting like this; in a nutshell, you have access to the request headers and body if you need any of their data for the code that you will execute inside of getSererSideProps). and again, if you inspect the page source, you will see all the data inside of the 'ul'.
// is getServerSideProps better than getStaticProps (since getServerSideProps runs for every request)? not always, since with getServerSideProps you will need to wait for your page to be generated with every incoming request. therefore, if you don't have data that changes all the time (like for example several times per second), or if you don't need to access the 'req' object (for example, for authentication), then getStaticProps will actually be better, because there you pre-generate an html file, that file can be stored and served by a CDN, and that's faster than pre-generating and fetching that data for every incoming request (the page can be catched and re-used instead of being pre-generated all the time). therefore, you should only use getServerSideProps if you need to use the 'req' object, or if you have data that changes several times every second, so even 'revalidate' from getStaticProps could not help you. therefore, in our meetups list, we better use getStaticProps, since our data doesn't change that often, and we don't use the incoming request 'req' object.

export async function getStaticProps() {
	// await fetch('...')
	// fetch data from api, or from a database, or read some files from the file system, etc.
	// once you have done anything you need, you have to return an object, with the 'props' property that will hold the props object that will be received in the component function (therefore, we no longer will need useState, and useEffect):
	return {
		props: {
			meetups: DUMMY_MEETUPS,
		},
		revalidate: 1,
	};
}
// next.js will look for a function with this name (getStaticProps) and if it finds it, it will execute this function during the pre-rendering process, so it will not directly call the component function, but first next.js will call getStaticProps, and the job of this function is to prepare the props for this page, and these props could contain the data that this page needs. and this function is allowed to be asynchronous, and next.js will wait for the returned promise to resolve, so it will wait until our data is loaded, and then we return the props for this component. therefore, we are loading the data before this component function (HomePage) is executed, so this component can be rendered with the required data. also, in getStaticProps you can execute any code that would normally only run on a server (access file system, connect to a database, etc.) because any code there will never end up on the client side and therefore will never be executed on the client side (because that code will be executed during the build process, not on the server, and not on the clients of your visitors). all and all, we are moving the data fetching from the client to the build process. now you can check the page source, and you will not see the empty 'ul' that you had before, and that's great for search engines.

export default HomePage;

// if you run 'npm run build' (this is the command that you execute in order to build your app, before you deploy it), you will see in the cli some info about the build: you will be able to check the static pages generated: the root page ('/'), the dynamic page ('[meetupId]'), the 404 page generated authomatically (for the case where the user types an incorrect url), and the newMeetup page. see the filled or empty dots: a filled dot (Static Site Generation, automatically generated as HTML + JSON (the json is used for pre-fetching data when the page is turned into an spa)). the empty dot stands for Static generation, which is almost the same as SSG, the only difference is that here we don't have initial props (we don't have inintial data that was fetched) (in our case, for the time being, only for the root page we are fetching data, that's the page where we added getStaticProps; later this will change).

// a problem that we could face with getStaticProps is that the data could be outdated: this page is generated during the build process. therefore, if we add more meetups after we have already deployed the page, this pre-generated page will not know about the new meetups, so if we don't add any client side data fetching, we will only see the outdated list of meetups. we could always re-build and re-deploy our side when our data changes, and this is a possible solution for some websites where the data doesn't change very frequently (for example, personal blogs). but if the data changes more frequently, we can add a property to the returned object by getStaticProps: 'revalidate'. when we add this property we unlock a feature called 'incremental static generation': we pass a number, for example 10, this number is the number of seconds that next.js will wait until it re-generates the website again for incoming requests. therefore, the page will not only be generated during the build process (although it will also be generated during the build process), but also be re-generated at least every 10 seconds ON THE SERVER (after deployment) if there are requests. and therefore the new re-generated pages will replace the old pre-generated pages, and you will make sure that your data is never older than 10 seconds. therefore, the number of seconds that you want to use depends on your data update frequency (how often your data changes). this way, you don't have to re-build and re-deploy all the time just because some data changed.

// but sometimes, even a regular update every certain number of seconds is not enough, ie. you will need to re-generate the page with every incoming request, so you want to pre-generate the page dynamically, on the fly, after deployment, on the server (not during the build process, not every couple of seconds, but for every request). in this case, we comment out getStaticProps, and export another function: getServerSideProps.
