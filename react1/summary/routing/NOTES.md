a router is a tool that watches for changes in the url, and changes what's visible on the screen based on the url.

npm install react-router-dom

CSS modules is a built in feature of CRA that allows us to scope style to components, the name of the file should be: name-of-component.module.css

the 'key' prop that React expects to render efficiently arrays of jsx elements, is one of the props that is built-in in any component, including in custom components, so you can use it anywhere.

react will authomatically pass an 'event' object as an argument to the function that is executed for events, such as onClick, onSubmit, etc

useRef: react allows us to set up references to dom elements, so we can get direct access to them. useRef() returns a reference object, so then you can use the 'ref' prop (another special prop that, like 'key' is built in all elements (including custom elements)) and assign the reference object to the prop. This will give you access to the element.

with SPAs, you need a backend API to which you can send your requests, a backend that won't send back html, but which expects data in certain format (usually JSON) and which sends data in that format (usually JSON), and which typically expose two urls that you can send requests to, and depending on which one you send a request to, different things will happen. That's the type of backend that you typically connect to with SPAs. You don't connect the frontend app to a database itself because of security issues (all the react code that you write is visible to the visitors of your page, through the dev tools>sources, there you can read the js code of the frontend of your app, and database credentials would be there as well if you include them in your react code). That's why we need a backend server to which we can send requests, and that server is connected to a database and stores data. We could build a RESTful api with node, for example, but we are going to use Firebase as a dummy backend (in one of the services of Firebase ('Realtime Database'), you can use it as a backend that offers you urls to which you can send requests to, and it will store the data safely in a database.)

'fetch' is the builtin javascript function to send http requests. we could install axios as well, but will stick to 'fetch'. however, fetch sends GET requests by default, that's why we add a second argument to configure the type of request we want to send: we configure the 'method' and 'body' (the data that you want to send, it has to be in JSON format). since the 'fetch' function returns a promise, we can use .then(()=>{})

in the Firebase Realtime Database service, you can add segments to the url domain, and then the data will be stored in different 'folders' or tables with that name that you add (in our case, we add '/meetups' to the url), and you also need to add '.json' at the end of the url.

react libraries also have hooks, for example react-router-dom has the useHistory hook, that returns an object that gives us methods to move around the history of the browser, so we can navigate programatially (the app will navigate on its own in certain situations). For example, the 'push' method will push a new page into the stack of pages so we will navigate away, but it will also allow us to click the 'back' button and go back to the form, which does not make sense, that's why we use the 'replace' method, which does the same but does not allow us to go back to the form.

in order to add the 'favourites' funcionality, we will have a state that will affect more than one component, we will need a mechanism to manage that state globally and distributing that state to different components. In order to do that, you could manage the state from the App component and distribute it down the different components through props. However, this have a couple of downsides: if you have a big application, you will have a lot of states to manage from the App component, and that's not ideal. Also, since you pass state through props, you will end up with very long prop chains: state passed through props from one component, to another component, and then to another component, etc., this can also make the code harder to maintain. That's why there are packages to manage application wide state (eg. Redux). However, React also has a built-in state management solution for application wide state, and that's a feature called 'context': you create a folder called 'store' (the name is a convention, since you are going to set up this state store for our app)...
