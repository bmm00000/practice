ReactDOM is our interface to the web; react.js doesn't know about the web or the browser, the only thing it knows is how to work with components, and state; ReactDOM is what will bring real html elements to the screen; reactdom is responsible for working with the real DOM, which is part of the browser and will be what the users will be able to see. React only cares about components, props (data you pass to components to make components configurable and to enable parent-child component communication), state (internal data inside of a component), and context (component-wide data). react checks if a component wants to render something new, and if so, react will let reactDOM know about that, so reactDOM will bring that new output to the screen.

react uses a concept called 'virtual dom': react determines how the component tree currently looks like, and how it should look like after a state update, and that info is handed over to reactdom, and reactdom knows how to manipulate the real dom to match that virtual dom, that virtual snapshot that react derived from your component tree

whenever state, props, or context of a component changes (at the end, everything comes down to state; if props change is because some state changed in a parent component...), that component function is re-executed (the component is re-evaluated by react). BUT re-executing/re-evaluating a component is not equivalent to re-rendering in the DOM. the real dom is only updated in the places where it needs to be changed, based on that difference that react derived between the previous state of a component and its tree, and the current state after the state, prop or context change: the real dom is changed only when needed, that's important for performance (a virtual comparison between a previous state and the current state is easier and chaper to do, it happens only in memory; reaching out to the real dom that is rendered in the browser is more expensive from a performance perspective so your site would become slow if you are working with the real dom too much). that's why react does this virtual comparisons with the virtual dom, and then only passes the changes between your last snapshot and the current snapshot to the real dom (it does a virtual dom diffing: finding out the difference between two snapshots)

in the screenshot example, reactdom will not re-render everything, it will not touch the div or h1 ('hi there'), it will only insert the paragraph ('this is new')

in short, react will diff the virtual doms, and then it will only pass to reactdom the differences, so reactdom can render them on the real dom

EVEN THOUGH WE re-execute a component, we don't re-initialize state every time. why is that? react makes sure that useState and the value that you pass as default, is only considered once. for subsequent re-evaluations, react recognizes that it already has a state for that component, and simply updates that state as needed. therefore, it will never re-initialize the state unless the component was completely removed from the dom (for example, if child components are rendered conditionally and mounted/unmounted from the dom, every time they are mounted again, then state will be initialized)
THE SAME APPLIES  to useReducer, for example.

when we update state, the former state is not immediately replaced after the state updating function is done running. what happens is that a state update is scheduled. in reality, scheduled updates will be processed pretty much instantly, but react reserves the right of postponing that state change (for example, because a lot of performance intensive tasks are going on at that precise moment (tasks that react considers as high priority)...), but react guarantees that the order of state changes for the same type of state is guaranteed (the order is kept, but it's not necessarily executed immediately). since multiple updates can be scheduled at the same time, it is recommended that you use the function format when the new state depends on a former state, so you ensure that you get the latest state to update your state (in most cases, it would work anyways, but just in the theoretical case that the update would be postponed, the function format is recommended). if you don't use the function format to update state when it's depending on a former state, then it could happen that, when there are many updates scheduled for the same component, you would get the state of, say, App, before the other outstanding updates have taken place in order. REMEMBER, when we use useEffect, the effect function is run only after the elements in the dependency array have been updated, that's why we can update state in the effect function using other states, since we know for sure that these states that are in the dependency array have already been updated. 

another situation: when we have two state updating functions after each other (this is just one syncronous process, without any callbacks or promisses in between). does it mean that the component is re-executed twice? NO. in that case, react will 'batch' these state updates together: react will take all state updates and will batch them together into just one state update (it's not two scheduled changes, but just one scheduled change which changes two different states)

another situation: sometimes, you may have functions that are a bit more performance intensive (for example, a sorting function that is passed a long list) and it may take some time. that's why you don't want to run this code every time the component gets re-evaluated. so far, we have learnt about react.memo to avoid unnecessary re-evaluations. but sometimes, we need to pass new props to the component, so the component will be re-evaluated, even when we use react.memo. Do we have any solution for this? the same way that we can use useCallback to store function objects, we can use the useMemo hook, that allows you to memoize (ie. to store), any kind of data that you want to store, just like useCallback does it for functions (ie. useMemo is the equivalent of useCallback (useCallback is only for functions), for any kind of data). useMemo will take as first argument a function that returns what you want to store. as second argument, the dependency array will contain the values that, when they change, will make the function run again, so we are sure that what we want to store is updated. note that, in the example of the screenshot, we also apply useMemo (with an empty dependencies array, since it all hardcoded, it doesn't have external dependencies) to the items prop that we pass to DemoList, since we don't want the items array (a reference type: even if the array contains the same numbers, it's a new array in memory) to be re-created every time we re-evaluate App (if it was re-created, then React.memo in DemoList would not work, because we would have different arrays with every re-render (because an array is a reference type). if we were passing a primitive type (for example: items={false}), this primitive type would be also re-created with every re-evaluation, but React.memo in DemoList would make the comparison between the old primitive and the new primitive that is passed, and since they are the same, DemoList would not be re-evaluated (this would not happen if the array was re-created: the old array and the new array would be different arrays).

you will use useMemo far less often that you use useCallback, because you will need to memoize functions more often that you will need to memoize data (you will only need to memoize data if it will be performance intensive to re-calculate something based on it; otherwise it might not be really worth it, because you have to keep in mind that using useMemo will also take some memory/performance, so it's not something you want to use on every value that you are using. in our example, we use it to avoid unnecessary sorting operations, and that might be well worth it; it's an optimization judgement that you have to make based on performance considerations, there's not a clear right or wrong)