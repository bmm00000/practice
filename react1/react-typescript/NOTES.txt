ts is a superset to js (a programming language that builds up on js and adds more features, and very importantly, adds static typing)

to install ts in a project:
npm install typescript
(previously, you will need to run 'npm init -y' in order to generate package.json file so you can install dependencies)

to install ts globally: 
npm install -g typescript

ts does not run in the browser, therefore we need to compile ts to js, and during the compilation process, all type annotations (and other ts features) will be removed (we will be notified about errors during this compilation step (we are also being notified in the IDE even before we compile))

to invoke the compiler (it will generate a js file, even if there are errors): 
npx tsc <name-of-file.ts>

USING TS IN A REACT PROJECT:

we need a react project that is configured to use ts instead of vanilla js. we still can use CRA for that (look at the CRA documentation on how to integrate ts: you can start a new project with ts integrated, or you can also add ts to an existing project; in either case you will get a project configured for ts). (in the CRA documentation, you also have more resources on how to get started with React and TS).

when we run the development server, under the hood, it's compiling the ts code into js code (in addition to the bundling/optimization that we also have when we are using a react project with vanilla js) (this would also happen if you build your code for production by running 'npm run build')

take a look at the dependencies in our react-ts project: you have 'typescript' (the ts compiler which is installed into this project) and '@types/...' as dependencies. '@types/...' act as translation bridges between vanila js libraries and ts projects. for example, usually we use 'react' and 'react-dom' as libraries in our react projects, but these two libraries are written for just js. in order to work with them in ts, and get IDE support, autocompletion, etc, we need translations between these vanilla js libraries and the ts project (so you could say that they are extra type annotations added to these js libraries). not all libraries need such translations because some libraries already have some built-in type annotations.  

in a react project with ts, the IDE warns you if you have code (eg. props) that you are not using. it will also warn you if the 'props' are of inferred type 'any' (since there's no point of leaving them like that in a ts project), but if you specify the type as 'props: any', then the warning will disappear.

you can configure how strict ts is in the tsconfig.json file.

the tsconfig.json file will configure the compilation from ts to js. in our react-ts project, the compiler is invoked authomatically when we start the development server or when we build the project for production (we are using a behind-the-scenes build workflow set up where the ts compiler is integrated):
target: constrols which js version to which your code will be transformed (depending on your setup, the 'target' option might not be the only thing that influences the output: there also can be project setups where your ts code might be compiled to js, and then you might have yet another compilation step with other tools like Babel that take that output js code and transform it even more. therefore, the 'target' might not be the last step, but it will often be).
lib: default ts libraries that are included, which influence which kind of types are known out of the box by our ts code (these libraries are built into ts, so we don't need to install any extra packages here, but in order to unlock them in our project we still need to list them under 'lib'). for example, 'dom' refers to types like the HTMLInputElement that we used.
allowJs: whether or not we can include plain .js files (if we want to mix ts with js files in our project)
strict: if true, we have the strictest possible setting in our project (eg. the non-implicit 'any' type: if you don't give types to parameters and infers 'any', it will give you an error)
jsx: controls that jsx code is supported and which output code should be generated.