a router is a tool that watches for changes in the url, and changes what's visible on the screen based on the url (so we give the user the illusion of routing), so we don't need to fetch a new html page (therefore, the page is fast and reactive, since everything is handled by client side JS, which is faster than sending a new request to a server)

INSTALL THE RIGHT REACT ROUTER VERSION:
npm install --save react-router-dom@5

once we have installed the router package, we create the 'pages' folder. This way, we separate the components that are embedded in other components ('components' folder) from the components that will be loaded as pages.

CSS modules is a built in feature of CRA (behind the scenes code transformation) that allows us to scope style to components, the name of the file should be: name-of-component.module.css

react will authomatically pass an 'event' object as an argument to the function that is executed for events, such as onClick, onSubmit, etc

useRef: react allows us to set up references to dom elements, so we can get direct access to them. useRef() returns a reference object, so then you can use the 'ref' prop (another special prop that, like 'key' is built in all elements (including custom elements)) and assign the reference object to the prop. This will give you access to the element.

with SPAs, you need a backend API to which you can send your requests, a backend that won't send back html, but which expects data in certain format (usually JSON) and which sends data in that format (usually JSON), and which typically expose two urls that you can send requests to, and depending on which one you send a request to, different things will happen. That's the type of backend that you typically connect to with SPAs. You don't connect the frontend app to a database itself because of security issues (all the react code that you write is visible to the visitors of your page, through the dev tools>sources, there you can read the js code of the frontend of your app, and database credentials would be there as well if you include them in your react code). That's why we need a backend server to which we can send requests, and that server is connected to a database and stores data. We could build a RESTful api with node, for example, but we are going to use Firebase as a dummy backend (in one of the services of Firebase ('Realtime Database'), you can use it as a backend that offers you urls to which you can send requests to, and it will store the data safely in a database.)

'fetch' is the builtin javascript function to send http requests. we could install axios as well, but will stick to 'fetch'. however, fetch sends GET requests by default, that's why we add a second argument to configure the type of request we want to send: we configure the 'method' and 'body' (the data that you want to send, it has to be in JSON format). since the 'fetch' function returns a promise, we can use .then(()=>{})

in the Firebase Realtime Database service, you can add segments to the url domain, and then the data will be stored in different 'folders' or tables with that name that you add (in our case, we add '/meetups' to the url), and you also need to add '.json' at the end of the url.

in order to add the 'favourites' funcionality, we will have a state that will affect more than one component, we will need a mechanism to manage that state globally and distributing that state to different components. In order to do that, you could manage the state from the App component and distribute it down the different components through props. However, this has a couple of downsides: if you have a big application, you will have a lot of states to manage from the App component, and that's not ideal. Also, since you pass state through props, you will end up with very long prop chains: state passed through props from one component, to another component, and then to another component, etc., this can also make the code harder to maintain. That's why there are packages to manage application wide state (eg. Redux). However, React also has a built-in state management solution for application wide state, and that's a feature called 'context': you create a folder called 'store' (the name is a convention, since you are going to set up this state store for our app)...
