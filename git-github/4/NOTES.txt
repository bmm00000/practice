https://www.canva.com/design/DAEPtdekgz0/L9rfbid7gCFMGEZBLJcmlw/view?utm_content=DAEPtdekgz0&utm_campaign=designshare&utm_medium=link&utm_source=sharebutton

ssh: secure shell (protocol that allows us to be authenticated without entering email and password each time). we need to generate one of these keys and tell github about it. the first thing you do is to check whether or not you already have a key (see screenshot)

https://docs.github.com/en/authentication/connecting-to-github-with-ssh

a remote is a destination URL where the hosted repo lives, and we give it a name (because urls are very long, a name is more convenient for us to fetch and push code). a very standard name for remotes is 'origin'. when you 'git remote -v', you can see the list of remote names and the urls they represent.

when you create a new repo in github, it doesn't have content, only the instructions (screenshot). when you push for the first time, then it gets the content

you can push any branch to github, but usually you may not want all your branches in github, or you may not want to push them all at once. often, you will push the master or main branch, and keep the other branches just in your local repo.

when you push a branch to origin (git push origin <branch-name>), you don't need to be on that branch, although that's what happens more often than not.

see screenshot: 'this branch is one commit ahead, one commit behind master'. What it means is that this branch has one commit that master doesn't have, but also that master has a commit that this branch doesn't have (this is the situation when there would be a merge commit if we merged these branches)

in github, you can see the most recent commit that affected each one of the files of the repo (see screenshot)

usually, what we do is we work with different branches in our local environment, then we merge into master, and then we push master to github (we don't usually push many branches into github).

git push origin cats (if the branch 'cats' doesn't exist yet in github, it will create it when we push our local 'cats' branch). the same will happen if we 'git push origin master' when the remote repo is empty (it will create the 'master' branch, and that will be the default branch in github(see screenshot)). usually, we want to connect the remote and local branches with the same name, but we don't have to.

when you follow the instructions in github to rename your local 'master' branch to 'main' (git branch -M main), it's assuming that you are checking out the local master branch, so you rename 'master' to 'main'.
but you don't need to rename your 'master' branch. you can just 'git push origin master', and that branch will be pushed to the remote repo (and it will be the default branch)

'git push -u origin dogs' will push the local branch 'dogs' to the origin 'dogs' branch (or create the origin 'dogs' branch if it doesn't exist yet), and connect these local and remote branches, so we can just use 'git push' and git will remember to what remote branch to push to, when whe push from the local 'dogs' branch.

you can also set an upstream with a different name (although in reality we would very rarely do this):
git push -u origin cats:dogs

'git push --set-upstream origin dogs' is the same as 'git push -u origin dogs'

WITH THE SECOND OPTION (CREATING A REPO ON GITHUB AND CLONING IT DOWN), you can add a .gitignore, README.md, and license, on github, and then clone it down and it will be done in your local.

if you create a new repo in github and you initialize it with a readme, .gitignore, etc., it will authomatically make a commit (it will call it 'initial commit' by default) and the default branch will be called 'main' (this happens since 2020). this will not happen if you create a repo in github and leave it empty: since there is no content, there will be no branch.
on the other hand, when you create a new repo in your local environment, and make the first commmit, the default branch is called 'master'

when you have a local repo with a 'master' branch as default (and it is also on github), but you want to change the name to 'main' to comply with the new naming convention: you change the name of the local branch to 'main', you push it to origin, and github will create a new branch called 'main'. however, the old 'master' branch will still be on github as the default one. you can make 'main' the default branch by going to 'settings', 'branches', 'default branch'

see screenshot: git log --oneline:
learn how to read lattest commits for different branches in origin

RE-DO VIDEO 105
observation doing the exercise: you can add the remote to your local repo even before you make the first commit in your local (github instructions tell you to make the first commit in your local first, and then add the remote, but you can add the remote before you make the first commit in local repo).

https://www.canva.com/design/DAEPyYicrxQ/EaXIXD_WWryEq7Z7YUSVlg/view?utm_content=DAEPyYicrxQ&utm_campaign=designshare&utm_medium=link&utm_source=sharebutton

when you clone a repo, the default name of the remote repo will be 'origin'

when you clone a repo, you will get the default ('main') branch in your local, BUT YOU WILL NOT GET THE OTHER BRANCHES (THAT YOU HAVE IN YOUR REMOTE REPO) IN YOUR LOCAL! but still, when you 'git branch -r', you will see that your local repo knows about the remote branches! but still you don't have the full-fledged branches in your local repo (you don't see them when you 'git branch')

relationship between a full-fledged branch and a remote tracking branch: by default, when we clone a repo, the local master branch we get in our local repo is already tracking/connected to the origin/master branch

but what if we want to work with another branch in our local repo? you can 'git checkout origin/puppies', but you will end up in detached head, and even if you create a new branch called 'puppies', this branch will not be connected to origin/puppies. how to solve this? EASY! 'git switch puppies' (this command will make the 'puppies' branch in your local and connect it to 'origin/puppies')

REMINDER: remote tracking branches (for example, 'origin/master') are in your local, not in github (see slide on 'git fetch'). the only thing that will update when you 'fetch' are the remote tracking branches. then, you will be able to checkout 'origin/master' without an internet connection (you will get into detached head, and check it out) (when you 'fetch' and update the remote tracking branches, these are in your computer, even though they are not in your working directory/workspace).

after you create new commits on github, when you 'git status' in your local, it will still tell you that 'your branch is up to date with 'origin/movies', because you are up to date with WHAT YOUR LOCAL REPO KNOWS 'ORIGIN/MOVIES' WAS (from last time you connected to the remote repo), NOT EXACTLY WHAT IT IS AT THIS MOMENT IN TIME (your local repo is not constantly updating from the repo on github; THE WAY TO ACHIEVE THIS IS WITH 'git fetch' (see screenshot))

'git fetch' is not only about updating remote tracking branches that were already in your local, but it will also show you new branches that were created in your github, but you didn't have them in your local yet as remote tracking branches (you cannot see them when you 'git branch -r', but you will see them when you 'git branch -r' after you 'git fetch')

when you 'git fetch' and the remote branch references get updated, if you 'git log', you won't see the remote branch references (you will only see them if the remote branch reference is pointing to a commit that is part of the history of your current head branch). but if you 'git status', you will see if the remote tracking branch is ahead, etc. then, you can 'git checkout origin/master' and you will go into detached head mode, and see what's going on in the remote tracking branch. if you 'git log' while you are checking out the remote tracking branch, you will see all the commits from the remote tracking branch.

corner case: when you have a remote tracking branch, and you 'git switch' to this branch for the first time, as we have seen, git sets up this branch in your local, USING THE LATEST INFO THAT IT HAS FROM THE LAST TIME IT CONNECTED TO ORIGIN (from the last time that you fetched) (ie. when you 'git switch', it doesn't connect to origin. you need to 'git fetch' to connect to origin)

git pull = git fetch (update remote tracking branch) + git merge (merge only the remote tracking branch that is the upstream of your local HEAD, into your local HEAD)

IT MATTERS FROM WHERE YOU 'GIT PULL': for example, 'git pull origin master' will update the remote tracking master branch, and then merge that branch into our current branch, WHATEVER THAT HAPPENS TO BE! 

QUESTION: if we 'git log' after pulling, will we see a new merge commit IF IT WAS NOT A FAST FORWARD merge AND ALSO THERE WAS NOT A CONFLICT?? YESSS! we will see the merge commit! (btw, the slide is wrong!)

as a good practice, before you push anything to github, you want to pull down and merge if any conflicts, (if there are conflicts and you make a commit to resolve them, then your local branch will be ahead respective the remote) and then you push (the only problem you may run into is that someone pushes something to github in the 30 seconds or so between the moment when you pull, and then push with your changes).
IN SHORT: MERGES ARE DONE WHEN PULLING, CANNOT BE DONE WHEN PUSHING!

in the slide where branches are merged after the pull, the yellow circle is at the end because it was done in local after the green ones were done in the remote repo, so the resulting order is chronological. KEEP IN MIND THAT THERE'S ONE COMMIT MISSING ON THE DIAGRAM! local must be 2 commits ahead of the remote (one is the yellow circle and the other one is the new merge commit done in local).

when you git pull, you update your (local) remote tracking branch with the remote branch, and then merge the (local) remote tracking branch into your local branch (if you git log after you pull, you will see all the commits coming from the remote branch together with your pre-existing local commits, chronologically). if there's a conflict, you will need to resolve it manually and make a commit.
QUESTION: if there's no conflict, but the merge is not a fast-forward, does git make a merge commit? YES!!!

MY OBSERVATION: you can establish a tracking connection between a remote branch and a local branch in two ways: 'git switch' to a branch with the name of a remote tracking branch (this is after you have cloned or fetched, but you don't have that branch in local yet), or you can also set the upstream with 'git push -u <remote> <local-branch-name>'

OTHER GITHUB FEATURES:
https://www.canva.com/design/DAEVGSMC0ew/9f6udCe20KrYAfwoD0zqHA/view?utm_content=DAEVGSMC0ew&utm_campaign=designshare&utm_medium=link&utm_source=sharebutton

in the example of inviting a collaborator in the screenshot, the repo is private. if the collaborator accepts the invitation, he can push to the repo, but he doesn't have access to 'settings' (he is a collaborator, not the owner), so he cannot do certain things (delete the repo, invite new collaborators or delete them, etc.). with 'enterprise' or 'team' github tiers, you can have different things, like several owners, different permissions, etc.

'markdown' is a tool that generates markup, ie. you write text with some simple sintax (markdown) and then github (or any other place that allows you to view markdown and render it yourself, like https://markdown-it.github.io/, or in vscode you can also preview it as you write it (command palette>Markdown Open Preview)) will be able to convert it to html (so you will save time since you don't need to write html):
https://daringfireball.net/projects/markdown/
https://markdown-it.github.io/

in any github project, you can see the markdown if you click on the 'raw' tag in the readme section

with gists, you can share snippets of code, solutions to problems, etc. with others without the hassle of creating new repo, pushing, etc. and it allows people to comment with suggestions, etc.
see example of gist in screenshot: using different github accounts with ssh keys (this gist is using a markdown file). it could have been a github repo with just one file on it, but the gist format is more convenient.
gists can be secret (hidden to search engines but visible to anyone you give the url to) or public.
you can add several files to a gist (see screenshot, we add a js file after the md file)
you also have other functionality like forking, stars, revisions (changes over history), etc., so it's like a mini repo.

it happens quite often that in the readme of a repo, there's a link to a github page, and that page will be the documentation for that project (see, for example, faker.js github repo). or also a link to the website of the project:
https://github.com/marak/Faker.js/
https://github.com/ovolve/2048-AI

when you are in a repo, go to 'settings'>'github pages', and select branch (you will need an index.html file in the root folder in that branch (or you can also specify the folder where the index.html file is, since it will ask you to specify the folder where the index.html file is)). what you can do is to create a separate branch (if you name it 'gh-pages', it will authomatically be detected) with an index.html file for your website (so you have the main branch for the project itself, without necessarily having an index.html file there)
when you want to update the website, the only thing you do is to push code to the branch that is used for the website

USE GITHUB PAGES TO LINK THE WEBSITE FOR MY FUTURE PROJECTS IN GITHUB
