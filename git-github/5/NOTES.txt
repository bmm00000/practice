https://www.canva.com/design/DAEP32iZwVc/4se77vKYGwT5_9NpxFbZoQ/view?utm_content=DAEP32iZwVc&utm_campaign=designshare&utm_medium=link&utm_source=sharebutton

the problem with the centralized workflow is that, you will always have to pull (and therefore merge) before you push your code. also, if you have changes that are not ready to be commited yet, and then someone asks you for your opinion about some mediocre code that they pushed, you have to pull that code, and therefore merge the mediocre code in your code base, and you will also probably have to stash your changes if you don't want to commit them yet. the point is that your colleagues had to 'break' the main branch (add mediocre code) in order for them to share their work with you. therefore, the branch is 'broken', not ready for production, will need to be fixed, and will potentially cause future problems if not fixed properly.

feature branch workflow: there are lot of patterns that companies use to name feature branches (eg. 'feat/navbar', etc.), we will not get into that.
before you create a new feature branch, you have to pull the 'main' branch to see if there are any updates.
(btw, you don't need to always push your feature branches to github, sometimes you will end up merging them with 'main' in your local, delete the feature branch, and push 'main')

if someone asks you for your opinion about their feature branch, you can either 'git fetch' and then 'git switch <feature/branch>', or, if you want to check before creating the branch in your local, you 'git fetch' and then 'git checkout origin/<feature/branch>' (you will go into detached head mode, and you won't end up with that feature branch in your local. after you checkout that branch, if you decide to make changes there, you can 'git switch <feature/branch>', and you will get the branch in your local, so you can work on it, commit and push)

every popular repo on github has a section for PRs:
https://github.com/facebook/react/pulls

in the feature branching workflow, we use PRs because you are a collaborator and have actually permission to push (push your feature branch). on the other hand, if you are working in an open source project, you usually use the fork and clone workflow: the contributors don't have permission to push changes to any of the branches. another way of making PRs is used: fork and clone workflow: common pattern to work with open source projects (eg. react) where you are not a collaborator (you don't have permission to push). there are a lot of patterns that you have to follow when contributing to an open source project (name conventions, tags, etc.)

changes can be added to a PR after it has been originally created.

after a PR has been approved, it's a good practice to delete the feature branch in github and also in your local.
after a PR has been approved, developers need to pull the main branch to have the latest version.

(look up different roles in github in public and private repos: owner, collaborator, contributor... and whether or not they can approve prs, etc.)

in order to resolve conflicts in PRs, you can either to it in the browser (click on 'resolve conflicts' button; you can do it in the browser if it's a small change or just one file, but if there are conflicts in many files, then it's more convenient to use the cli), or in the cli (click on 'command line instructions' to see how to do it) (see screenshot):
github still uses the older command: 'git checkout -b new-heading origin/new-heading' (make me a new branch called 'new-heading' and make it track 'origin/new-heading'), but the easier option would be to 'git switch origin/new-heading'.
the approach is: switch to the feature branch, and then merge 'main' into the feature branch, and resolve the conflicts while doing so.
I DON'T UNDERSTAND WHY WE HAVE TO MERGE TWICE?
REPLY: Absolutely you could skip that step and merge your changes into master.  It's just that most people want to keep master "clean" and not deal with conflict resolution on master.  Instead, we merge master into a feature branch and deal with the conflicts on the feature branch. after that, if you delete the feature branch, the conflict resolution commit will be gone, so the 'main' branch will be cleaner.

--no-ff: we are indicating git not to fast forward even if it detects that it can. we do this because we want in any case a merge commit (even if it could do a fast forward) in order to be clearer about the history of our project (you don't have to do this, but this is what github recommends)
It's just a matter of preference/style.  Many companies like to have a very explicit, clear record of the repo history.  Fast forward merges aren't easily detectable because they don't result in a new distinct commit.

another thing we can do when working with a lot of collaborators is to configure branch protection rules to establish some quality control and review/feedback process over the main branch. we go to 'settings', 'branches', there you can decide which one is your default branch. there, you also have 'branch protection rules'
if you click on 'add', you will see 'branch name pattern' because you can add rules for sets of branches called, for example, 'feature/whatever-name'. you can also add the specific name of the branch, eg. 'main'
see the screenshots to follow the example.

after someone approves it (as we specified in our rule), then the PR also has to be merged.

the fork and clone workflow allows a whole bunch of people to work on the same project without actually having permissions for the same repo.

when you fork a repo, you can add your own collaborators, add branch protection rules, delete branches, etc.

the upstream remote is for you to pull regularly from the original repo, so you get all updates (you cannot push because you don't have permission). in other words, your fork is frozen after you get it, it will not be updated from the original repo. the only way to get updates is by pulling from the original repo (upstream). in order to do that, you need to:
git remote add upstream <original-repo-url>