https://www.canva.com/design/DAEVkyNcwWI/qt8pRN3JA1lP9ckYeImxeQ/view?utm_content=DAEVkyNcwWI&utm_campaign=designshare&utm_medium=link&utm_source=sharebutton#1

as you merge the master branch into your feature branch many times to keep your feature branch updated with your colleagues' work, your feature branch history gets muddied, and later, when you (and your colleagues... imagine a big open source project) eventually merge your feature branches into master, all that mud (many many merge commits) get into the history of the master branch. we are not saying that these commits are useless, but they are not informative 

rebase: come with a new 'base' for our feature branch
when we rebase, commits are re-written: this doesn't indicate the time when commits were created (each commit has a original date, metadata, etc. and that is preserved) but commits are moved around in order to give us a new structure, so all the commits of the feature branch begin at the tip of the master branch (so you don't have merge commits). therefore, all the work from the master branch is included in the feature branch. the feature branch has a new base (at the tip of the master branch). we end up with a structure that is linear, cleaner and other developers can understand it better (imagine a big open source project, others will be able to better understand the history of our project).

as it happens in the demo, even after you have done the merge commits, you can rebase and end up with the linear structure that we want (and the merge commits will be gone)

when we rebase and 're-write history', what happens is that git creates new commits on the top of the base branch (these new commits have different hashes that the original ones that we had in our original feature branch, but the original hashes from the master branch DO NOT change) 