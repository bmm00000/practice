js is single-threaded, but the browser (or node.js) is not! the environment where js runs (browser or node.js) is able to use multiple threads. by calling setTimeout (a function made avaialble by the browser or node.js), we let the environment (browser or node.js) to know about the fact that we want to set a timer and what function we want to call when the timer completes. and then js, with its single thread is done (this operation is done): setTimeout doesn't set a timer that is managed by js, but it's just a trigger to communicate with the environment in which our script runs, so that the environement (browser or node.js) internally is able to set a timer (and the environment is not single threaded, so it can set a timer and then do other things at the same time). therefore, the js thread is done, it can move on to the next operation, and now the browser knows the function that should be called when the timer completes. and timers are just an example, the same happens if we set a click listener on a button: js in its single thread is not watching that button, but it lets the browser know that this button has such a click listener and that a certain function should be triggered by the browser when the button is clicked. THAT'S HOW ALL ASYNC OPERATIONS WORK: certain features are made avaialble by the environment in which js runs, and js hands over those tasks to the environment, and the environment lets js know about them once they are done, or once certain event occurs. eg. when the timer expires, the browser will come back to the js engine and tell it that certain function should be executed now. therefore, js only has to do one thing at a time, either hand over that info to the browser, or, when the timer expires, call certain function.

WAYS (techniques or tools) TO DEAL WITH ASYNC OPERATIONS:
1. the oldest way to deal with async operations is by callback functions (many of the apis (features) provided by the browser or node.js expect callbacks): define which function should be executed and you pass  a pointer at that function to setTimeout, to addEventListener, and to many other functions and apis that are made avaialble by the environment in which we are running our js code. DON'T FORGET: functions like setTimeout are built into the environment and they are made available to js by that environment (therefore, it's the environment who deals with the async operation). with callbacks, what we do is to let the environement know about the operation that we want to do (eg. set a timer or an event listener), and we let the environement also know about which function should eventually be called when that timer expires or when that event occurs.

2. in modern js, we also got promises: you still work with callback functions, but if you have multiple dependent operations, you build a step-by-step chain of those possibly async operations, and therefore you have an easier time building more complex reaction chains. all modern apis provided by the environments (browser, node.js) support promises, but older apis like setTimeout and addEventListener have no built-in promise support, but you can also make those older apis work with promises (we will see how to do it). a promise is a js object (a feature built into modern js) that wraps a certain operation (that can be an async operation, but doesn't have to be one). eventually this promise gets marked as settled (whenever that operation finishes). if it's a synchronous operation that's instantly the case, but if it's an async operation, it will take some time. then you can tell the promise what code should be exeucted once this operation is done (once this promise is settled), and you do this by calling a special method on the promise (at the end, it's a js object): the 'then' method, which takes a function as an argument that will be executed once the promise is settled. in more complex apps, you might face a problem that we usually refer to as 'callback hell' (see slide: the more nested callbacks you have, the harder your code becomes to read; if you work with more complex projects, with certain libraries, access data from a server, extract it, do something else with it, etc. you may end up in situations where you have a lot of dependent operations which you need to nest like we have in the 'callback hell' example). in order to avoid such complex code, we have promises (see example of slide: keep in mind that 'addListener' and 'setTimer' are not apis that are provided like this, but we will see later how to wrap existing apis with our own promise versions)  