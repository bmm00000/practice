closures is a mechanism that exists in many programming languages. it's about locking values (or locking variables to be precise) into functions.

by default, every function forms a closure, and we call it a closure because it closes over the variables which are in scope at the point of time the function is declared.

in our example, the createGreeter function is basically a function factory: we return function every time we call createGreeter. the returned function simply logs something into the console, and that something that is logged is a variable defined in createGreeter (not defined inside of that anonymous function that is returned). the interesting thing is that we first call createGreeter, and then we call the returned function at a later point in time (once createGreeter is already finished (we don't call the anonymous function inside of createGreeter, but outside of it)): the fact that we have access to the myName variable inside of the returned anonymous function that we call later is interesting (because we have access to that variable after createGreeter is already dead, ie. after the execution of createGreeter is already done). this happens because every function is a closure. the anonymous function maintains a reference to its environment when it was declared, and that environment simply describes the scope at the point of time it was declared (ie. it describes all the variables that it had access to when it was declared). the anonymous function was declared when createGreeter was executed, and at this point in time, the myName constant existed, because that declaration happenned during the execution of createGreeter, and there we have myName.